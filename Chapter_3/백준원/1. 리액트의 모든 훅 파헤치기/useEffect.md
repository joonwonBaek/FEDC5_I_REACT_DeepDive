# useEffect

애플리케이션 내 컴포넌트의 여러 값들을 활용해 동기적으로 부수 효과를 만드는 메커니즘이다. 이 부수 효과가 '언제' 일어나는지보다 어떤 상태값과 함께 실행되는지 살펴보는 것이 중요

## useEffect란?

useEffect의 일반적인 형태는 첫번째 인수로는 실행할 부수 효과가 포함된 함수, 두 번째 인수로는 의존성 배열을 전달한다.

의존성 배열이 변경될 때마다 useEffect의 첫 번째 인수인 콜백을 실행한다. 그러나 useEffect는 어떻게 의존성 배열이 변경된 것을 알고 실행될까?

useEffect는 렌더링 할 때마다 의존성에 있는 값을 보면서 이 의존성의 값이 이전과 다른 게 하나라도 있으면 부수 효과를 실행하는 평범한 함수라 볼 수 있다.

따라서 useEffect는 state와 props의 변화 속에서 일어나는 렌더링 과정에서 실행되는 부수 효과 함수라고 볼 수 있다.

## 클린업 함수의 목적

클린업 함수라 불리는 useEffect 내에서 반환되는 함수는 정확히 무엇이고 어떤 일을 할까? 일반적으로 이 클린업 함수는 이벤트를 등록하고 지울 때 사용해야 한다고 알려져 있다.

클린업 함수는 이전 state를 참조해 실행, 새로운 값과 함께 렌더링된 뒤에 실행되지만 이 변경된 값을 읽는 것이 아니라 함수가 정의됐을 당시에 선언됐던 이전 값을 보고 실행

함수형 컴포넌트의 useEffect는 그 콜백이 실행될 때마다 이전의 클린업 함수가 존재한다면 그 클린업 함수를 실행한 뒤에 콜백을 실행한다.

따라서 이벤트를 추가하기 전에 이전에 등록했던 이벤트 핸들러를 삭제하는 코드를 클린업 함수에 추가하는 것이다. 이렇게 함으로써 특정 이벤트의 핸들러가 무한히 추가되는 것을 방지할 수 있다.

생명주기 메서드의 언마운트 개념과 조금 차이가 있다.

`언마운트`는 특정 컴포넌트가 DOM에서 사라진다는 것을 의미하는 클래스형 컴포넌트 용어

`클린업 함수`는 언마운트라기보다는 함수형 컴포넌트가 리렌더링됐을 때 의존성 변화가 있었을 당시 이전의 값을 기준으로 실행되는, 말 그대로 이전 상태를 청소해 주는 개념

## 의존성 배열

의존성 배열은 `보통 빈 배열`을 두거나, 아예 `아무런 값도 넘기지 않거나`, 혹은 `사용자가 직접 원하는 값`을 넣어줄 수 있다.

빈 배열 : useEffect는 비교할 의존성이 없다고 판단해 최초 렌더링 직후에 실행된 다음부터는 더 이상 실행되지 않는다.

아무런 값도 넘기지 않는 경우 : 의존성을 비교할 필요 없이 렌더링할 때마다 실행이 필요하다고 판단해 렌더링이 발생할 때마다 실행이 필요하다고 판단해 렌더링이 발생할 때마다 실행 => 보통 컴포넌트가 렌더링됐는지 확인하기 위한 방법으로 사용

```JavaScript
/// 1
function Component() {
  console.log("렌더링됨");
}

/// 2
function Component() {
  useEffect(() => {
    console.log("렌더링됨");
  });
}
```

두 코드의 차이점

- 이후에 소개할 서버 사이드 렌더링 관점에서 useEffect는 클라이언트 사이드에서 실행되는 것을 보장해 준다. useEffect 내부에서는 window 객체의 접근에 의존하는 코드를 사용해도 된다.
- useEffect는 컴포넌트 렌더링의 부수 효과, 즉 컴포넌트의 렌더링이 완료된 이후에 실행된다. 반면 직접 실행은 컴포넌트가 렌더링되는 도중에 실행된다. 따라서 1번과는 달리 서버 사이드 렌더링의 경우에 서버에서도 실행된다. 그리고 이 작업은 함수형 컴포넌트의 반환을 지연시키는 행위이다. 즉 무거운 작업일 경우 렌더링을 방해하므로 성능에 악영향을 미칠 수 있다.

useEffect는 컴포넌트가 렌더링된 후에 어떠한 부수 효과를 일으키고 싶을 때 사용하는 훅

## useEffect를 사용할 때 주의할 점

useEffect는 리액트 코드를 작성할 때 가장 많이 사용하는 훅이면서 가장 주의해야 할 훅

### useEffect의 첫 번째 인수에 함수명을 부여하라

useEffect를 사용하는 많은 코드에서 useEffect의 첫 번째 인수로 익명 함수를 넘겨준다.

useEffect의 수가 적거나 복잡성이 낮다면 이러한 익명 함수를 사용해도 큰 문제는 없다. 그러나 useEffect의 코드가 복잡하고 많아질수록 무슨 일을 하는 useEffect 코드인지 파악하기 어려워진다.

useEffect의 인수를 익명 함수가 아닌 적절한 이름을 사용한 기명 함수로 바꾸는 것이 좋은 이유는 해당 변수가 왜 만들어졌는지 파악할 수 있기 때문이다.

```JavaScript
useEffect(
  function logActiveUser() {
    logging(user.id);
  },
  [user.id]
);
```

useEffect의 목적을 명확히 하고 그 책임을 최소한으로 좁힌다는 점에서 굉장히 유용

### 거대한 useEffect를 만들지 마라

부수 효과의 크기가 커질수록 애플리케이션 성능에 악영향을 미친다.

가능한 한 useEffect는 간결하고 가볍게 유지하는 것이 좋다. 만약 부득이하게 큰 useEffect를 만들어야 한다면 적은 의존성 배열을 사용하는 여러 개의 useEffect로 분리하는 것이 좋다.

의존성 배열이 너무 거대하고 관리하기 어려운 수준까지 이른다면 정확히 이 useEffect가 언제 발생하는지 알 수 없다.

의존성 배열에 불가피하게 여러 변수가 들어가야 하는 상황이라면 useCallback과 useMemo 등으로 사전에 정제한 내용들만 useEffect에 담아두는 것이 좋다

### 불필요한 외부 함수를 만들지 마라

useEffect 내에서 사용할 부수 효과라면 내부에서 만들어서 정의해서 사용하는 편이 훨씬 도움이 된다.

### 왜 useEffect의 콜백 인수로 비동기 함수를 바로 넣을 수 없을까?
